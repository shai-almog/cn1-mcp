<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NativeStubService.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mcp</a> &gt; <a href="index.source.html" class="el_package">com.codename1.server.mcp.service</a> &gt; <span class="el_source">NativeStubService.java</span></div><h1>NativeStubService.java</h1><pre class="source lang-java linenums">package com.codename1.server.mcp.service;

import com.codename1.server.mcp.dto.FileEntry;
import com.codename1.server.mcp.dto.NativeStubRequest;
import com.codename1.server.mcp.dto.NativeStubResponse;
import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;
import javax.tools.DiagnosticCollector;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

/** Compiles user-provided Java sources and generates Codename One native interface stubs. */
@Service
<span class="fc" id="L33">public class NativeStubService {</span>
<span class="fc" id="L34">  private static final Logger LOG = LoggerFactory.getLogger(NativeStubService.class);</span>

  /**
   * Generates native stubs for the given request.
   *
   * @param request the compilation request describing the interface and supporting files
   * @return the generated native stub files
   */
  public NativeStubResponse generate(NativeStubRequest request) {
<span class="fc" id="L43">    Objects.requireNonNull(request, &quot;request&quot;);</span>
<span class="pc bpc" id="L44" title="2 of 4 branches missed.">    if (request.interfaceName() == null || request.interfaceName().isBlank()) {</span>
<span class="nc" id="L45">      throw new IllegalArgumentException(&quot;interfaceName is required&quot;);</span>
    }
<span class="pc bpc" id="L47" title="2 of 4 branches missed.">    if (request.files() == null || request.files().isEmpty()) {</span>
<span class="nc" id="L48">      throw new IllegalArgumentException(&quot;At least one source file is required&quot;);</span>
    }

<span class="fc" id="L51">    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();</span>
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">    if (compiler == null) {</span>
<span class="nc" id="L53">      throw new IllegalStateException(&quot;A JDK is required to generate native stubs&quot;);</span>
    }

    Path sourceDir;
    Path classesDir;
    try {
<span class="fc" id="L59">      sourceDir = Files.createTempDirectory(&quot;cn1-native-src&quot;);</span>
<span class="fc" id="L60">      classesDir = Files.createTempDirectory(&quot;cn1-native-classes&quot;);</span>
<span class="nc" id="L61">    } catch (IOException e) {</span>
<span class="nc" id="L62">      throw new IllegalStateException(&quot;Failed to allocate temporary workspace&quot;, e);</span>
<span class="fc" id="L63">    }</span>

    try {
<span class="fc" id="L66">      Map&lt;String, FileEntry&gt; provided = new LinkedHashMap&lt;&gt;();</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">      for (FileEntry entry : request.files()) {</span>
<span class="pc bpc" id="L68" title="2 of 4 branches missed.">        if (entry.path() == null || entry.path().isBlank()) {</span>
<span class="nc" id="L69">          throw new IllegalArgumentException(&quot;File path is required&quot;);</span>
        }
<span class="fc" id="L71">        Path dest = resolveRelativePath(sourceDir, entry.path());</span>
<span class="fc" id="L72">        Path parent = dest.getParent();</span>
<span class="pc bpc" id="L73" title="1 of 2 branches missed.">        if (parent != null) {</span>
<span class="fc" id="L74">          Files.createDirectories(parent);</span>
        }
        // SpotBugs: top-level files resolve without parents; no directories are required in that
        // case.
<span class="fc" id="L78">        Files.writeString(dest, entry.content(), StandardCharsets.UTF_8);</span>
<span class="fc" id="L79">        provided.put(entry.path(), entry);</span>
<span class="fc" id="L80">      }</span>

<span class="fc" id="L82">      ensureStub(</span>
          sourceDir,
          provided,
          &quot;com/codename1/system/NativeInterface.java&quot;,
          &quot;&quot;&quot;
                            package com.codename1.system;

                            public interface NativeInterface {
                              boolean isSupported();
                            }
                            &quot;&quot;&quot;
<span class="fc" id="L93">              .replace(&quot;\n&quot;, System.lineSeparator()));</span>
<span class="fc" id="L94">      ensureStub(</span>
          sourceDir,
          provided,
          &quot;com/codename1/ui/PeerComponent.java&quot;,
          &quot;&quot;&quot;
                            package com.codename1.ui;

                            public class PeerComponent {}
                            &quot;&quot;&quot;
<span class="fc" id="L103">              .replace(&quot;\n&quot;, System.lineSeparator()));</span>

<span class="fc" id="L105">      List&lt;Path&gt; sources = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L106">      try (var stream = Files.walk(sourceDir)) {</span>
<span class="fc" id="L107">        stream.filter(p -&gt; p.toString().endsWith(&quot;.java&quot;)).forEach(sources::add);</span>
      }

<span class="fc" id="L110">      DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;&gt;();</span>
<span class="fc" id="L111">      try (StandardJavaFileManager fileManager =</span>
<span class="fc" id="L112">          compiler.getStandardFileManager(diagnostics, Locale.ROOT, StandardCharsets.UTF_8)) {</span>
<span class="fc" id="L113">        Iterable&lt;? extends JavaFileObject&gt; compilationUnits =</span>
<span class="fc" id="L114">            fileManager.getJavaFileObjectsFromPaths(sources);</span>
<span class="fc" id="L115">        List&lt;String&gt; options =</span>
<span class="fc" id="L116">            List.of(</span>
<span class="fc" id="L117">                &quot;-classpath&quot;, System.getProperty(&quot;java.class.path&quot;), &quot;-d&quot;, classesDir.toString());</span>
<span class="fc" id="L118">        JavaCompiler.CompilationTask task =</span>
<span class="fc" id="L119">            compiler.getTask(null, fileManager, diagnostics, options, null, compilationUnits);</span>
<span class="fc" id="L120">        Boolean ok = task.call();</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">        if (!Boolean.TRUE.equals(ok)) {</span>
<span class="nc" id="L122">          StringBuilder message = new StringBuilder(&quot;Compilation failed:&quot; + System.lineSeparator());</span>
<span class="nc" id="L123">          diagnostics</span>
<span class="nc" id="L124">              .getDiagnostics()</span>
<span class="nc" id="L125">              .forEach(d -&gt; message.append(d).append(System.lineSeparator()));</span>
<span class="nc" id="L126">          throw new IllegalArgumentException(message.toString());</span>
        }
      }

<span class="fc" id="L130">      try (URLClassLoader loader =</span>
<span class="fc" id="L131">          AccessController.doPrivileged(</span>
              // SpotBugs: creating the class loader under doPrivileged avoids
              // DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED.
              (PrivilegedExceptionAction&lt;URLClassLoader&gt;)
                  () -&gt;
<span class="fc" id="L136">                      new URLClassLoader(</span>
<span class="fc" id="L137">                          new URL[] {classesDir.toUri().toURL()}, getClass().getClassLoader()))) {</span>
        Class&lt;?&gt; iface;
        try {
<span class="fc" id="L140">          iface = Class.forName(request.interfaceName(), true, loader);</span>
<span class="nc" id="L141">        } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L142">          throw new IllegalArgumentException(</span>
<span class="nc" id="L143">              &quot;Interface not found after compilation: &quot; + request.interfaceName(), e);</span>
<span class="fc" id="L144">        }</span>
<span class="fc" id="L145">        NativeStubGenerator generator = new NativeStubGenerator(iface);</span>
<span class="fc" id="L146">        String validation = generator.verify();</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        if (validation != null) {</span>
<span class="fc" id="L148">          throw new IllegalArgumentException(validation);</span>
        }
<span class="fc" id="L150">        Map&lt;String, String&gt; generated = generator.generate();</span>
<span class="fc" id="L151">        LOG.info(</span>
            &quot;Generated {} native stub files for interface {}&quot;,
<span class="fc" id="L153">            generated.size(),</span>
<span class="fc" id="L154">            request.interfaceName());</span>
<span class="fc" id="L155">        List&lt;FileEntry&gt; files =</span>
<span class="fc" id="L156">            generated.entrySet().stream()</span>
<span class="fc" id="L157">                .sorted(Map.Entry.comparingByKey())</span>
<span class="fc" id="L158">                .map(e -&gt; new FileEntry(e.getKey(), e.getValue()))</span>
<span class="fc" id="L159">                .toList();</span>
<span class="fc" id="L160">        return new NativeStubResponse(files);</span>
      }
<span class="nc" id="L162">    } catch (PrivilegedActionException e) {</span>
<span class="nc" id="L163">      throw new IllegalStateException(</span>
<span class="nc" id="L164">          &quot;Failed to open class loader for generated sources&quot;, e.getException());</span>
<span class="nc" id="L165">    } catch (IOException e) {</span>
<span class="nc" id="L166">      throw new IllegalStateException(&quot;Failed to generate native stubs&quot;, e);</span>
    } finally {
<span class="fc" id="L168">      cleanup(sourceDir);</span>
<span class="fc" id="L169">      cleanup(classesDir);</span>
    }
  }

  private static void ensureStub(
      Path sourceDir, Map&lt;String, FileEntry&gt; provided, String relativePath, String content)
      throws IOException {
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">    if (provided.containsKey(relativePath)) {</span>
<span class="nc" id="L177">      return;</span>
    }
<span class="fc" id="L179">    Path dest = resolveRelativePath(sourceDir, relativePath);</span>
<span class="fc" id="L180">    Path parent = dest.getParent();</span>
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">    if (parent != null) {</span>
<span class="fc" id="L182">      Files.createDirectories(parent);</span>
    }
    // SpotBugs: bundled stubs might live at the workspace root; those require no parent
    // directories.
<span class="fc" id="L186">    Files.writeString(dest, content, StandardCharsets.UTF_8);</span>
<span class="fc" id="L187">  }</span>

  private static Path resolveRelativePath(Path sourceDir, String requestedPath) {
<span class="fc" id="L190">    Path relative = Path.of(requestedPath);</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">    if (relative.isAbsolute()) {</span>
<span class="nc" id="L192">      throw new IllegalArgumentException(&quot;File path must be relative: &quot; + requestedPath);</span>
    }
<span class="fc" id="L194">    Path normalized = sourceDir.resolve(relative).normalize();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">    if (!normalized.startsWith(sourceDir)) {</span>
<span class="fc" id="L196">      throw new IllegalArgumentException(&quot;File path escapes workspace: &quot; + requestedPath);</span>
    }
<span class="fc" id="L198">    return normalized;</span>
  }

  private static void cleanup(Path dir) {
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">    if (dir == null) {</span>
<span class="nc" id="L203">      return;</span>
    }
<span class="fc" id="L205">    try (var stream = Files.walk(dir)) {</span>
<span class="fc" id="L206">      stream</span>
<span class="fc" id="L207">          .sorted(Comparator.reverseOrder())</span>
<span class="fc" id="L208">          .forEach(</span>
              path -&gt; {
                try {
<span class="fc" id="L211">                  Files.deleteIfExists(path);</span>
<span class="nc" id="L212">                } catch (IOException ex) {</span>
<span class="nc" id="L213">                  LOG.debug(&quot;Failed to delete native stub temp file {}&quot;, path, ex);</span>
<span class="fc" id="L214">                }</span>
<span class="fc" id="L215">              });</span>
<span class="nc" id="L216">    } catch (IOException ex) {</span>
<span class="nc" id="L217">      LOG.debug(&quot;Failed to clean native stub temp directory {}&quot;, dir, ex);</span>
<span class="fc" id="L218">    }</span>
<span class="fc" id="L219">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>